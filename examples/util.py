"""Example utilitites."""
from os import environ, path
import logging
import json

from jwcrypto.jwt import JWT


# pylint:disable=invalid-name
logger = logging.getLogger(__name__)


REPO_ROOT = path.dirname(path.dirname(__file__))


def load_key_text(filepath=''):
    """Load the text from a private key file.

    Args:
        filepath (str): the filepath to load from. Defaults to the environment
            variable PRIVATE_KEY_FILE. If this is not set, raises ValueError.
    """
    if not filepath:
        raise ValueError('Invalid filepath', filepath)
    if not path.isfile(filepath):
        raise ValueError('Path "%s" does not point to a file', filepath)
    logger.debug('Loading key text from %s', filepath)
    with open(filepath, 'r') as private_key_file:
        return private_key_file.read()


def get_kid():
    """Get the kid (i.e. key ID) header value.

    The 'kid' is used as a header in JWTs. It identifies which JWK should be
    used to verify a signature. For more information see:
    http://stackoverflow.com/questions/43867440/ddg#43870513

    In the case of Mobile Connect's Server Initiated API, the kid identifies a
    key which will have been agreed (TODO: by whom?) before any SI requests are
    sent; the operator will have a copy of the relevant public key.

    In these examples the kid can be specified by setting the KID environment
    variable; otherwise, it defaults to 'developer-app'.
    """
    return environ.get('KID', 'developer-app')



# Keys which are required by the request object; included for reference.
REQUEST_OBJECT_REQUIRED_KEYS = (
    'response_type', 'client_id', 'scope', 'version', 'nonce', 'login_hint',
    'acr_values', 'client_notification_token', 'notification_uri', 'iss',
    'aud',
)


def get_raw_request_object(overrides=None):
    """Create a raw (unsigned) request object for use in examples.

    Args:
        overrides (dict): optional overrides for request object fields.
    """
    client_id = environ.get(
        'CLIENT_ID', 'x-a94d903f-ad45-4135-80b8-ac459f41b38f')
    request_object = {
        # The `response_type` field is required in the request object, but can
        # currently only take the value "mc_si_async_code". Having this allows
        # for possible changes in the API at a later date.
        'response_type': environ.get('RESPONSE_TYPE', 'mc_si_async_code'),
        # The `client_id` field is obtained from the Discovery response; it is
        # used as the unique client identifier of the service provider.
        'client_id': client_id,
        # The scope identifies the scope of this request, i.e. the services
        # being requested. Its usage here is the same as in other parts of the
        # MC API, e.g. with DI authorization requests.
        'scope': environ.get('scope', 'openid mc_atp'),
        # The `version` field is required, but currently must be
        # "mc_si_r2_v1.0". This allows for possible changes in API
        # functionality at a later date.
        'version': environ.get('VERSION', 'mc_si_r2_v1.0'),
        # The `nonce` is a string (TODO: generated by whom?) which associates a
        # client session with the ID token; the recommended format is UUID4.
        'nonce': environ.get('NONCE', '878aacd7-83f1-4b4f-9582-7347b0a6fa62'),
        # From the spec: the `login_hint` field is an indication to the ID
        # GW/Authorization Server on what ID to use for login, e.g. email,
        # MSISDN (phone_number), etc. The recommendation is that the value
        # matches the value used in Discovery.
        # The login_hint can contain the MSISDN, encrypted MSISDN or PCR. The
        # format MUST be as MSISDN:<Value>,ENCR_MSISDN:<Value> and PCR:<value>
        # The usage to transport the encrypted MSISDN will be deprecated in
        # future releases; instead login_hint_token will be used.
        'login_hint': environ.get('LOGIN_HINT', 'MSISDN:447700900907'),
        # From the spec:
        # Authentication Context Class Reference. Space separated string that
        # specifies the Authentication Context Reference used during
        # authentication processing. The RP/Client can use LoA for a particular
        # use case. The values appear in order of preference. The acr satisfied
        # by the authentication is returned as the acr claim value. ID GW MUST
        # consider only the first value in the list, and ignores remaining LoA
        # values while processing the request.  The RECOMMENDED values are the
        # LoAs as specified in ISO/IEC 29115 Clause 6 – 1, 2, 3, 4 –
        # representing the LoAs of LOW, MEDIUM, HIGH and VERY HIGH.
        # The acr_values are an indication of what authentication method to use
        # by the ID GW. The usage of authentication methods depends on the LoA
        # value passed in the parameter acr_values. The ID GW configures the
        # authentication method selection logic based on the acr_values.
        # ID GW/Authorization server MUST return the achieved level of
        # assurance in the acr parameter.
        'acr_values': int(environ.get('ACR_VALUES', '3')),
        # A token used by the IDGW to authenticate when using the service
        # provider's client notification endpoint (passed as the bearer token).
        # This is provided by the service provider.
        # (Background: service providers are required to operate a notification
        # endpoint in order for the IDGW to respond with an ID token (the JWT)
        # and an access token. See IDY.02, section 6.3.1 for more details.)
        'client_notification_token': environ.get(
            'CLIENT_NOTIFICATION_TOKEN',
            'Wm1VFlURXpNR1V0T0Rjek1TMDBOVFpqTFdGalpEZ3'),
        # The URI for the notification endpoint described above. This is
        # operated by the service provider and must equal the
        # `notification_uri` registered for the SP during onboarding.
        'notification_uri': environ.get(
            'NOTIFICATION_URI' 'https://mc.example.com/callback'),
        # The issuer ID. The ID of the party signing the request. This should
        # be the client_id in most cases, and must use the HTTPS protocol. For
        # specifics see IDY.02 section 6.3.3 and the Open ID spec:
        # https://openid.net/specs/openid-connect-core-1_0.html#RequestObject
        'iss': environ.get('ISS', client_id),
        # The audience ID. The ID of the intended recipient of the request
        # object. This should be the client_id of the "Relying Party", i.e. the
        # OAuth 2.0 client application requiring authorization. For more
        # details see IDY.02 or the Open ID spec:
        # https://openid.net/specs/openid-connect-core-1_0.html#RequestObject
        'aud': environ.get('AUD', 'https://operator.example.com'),
    }

    # Optional request object parameters; these are provided for the sake of
    # example only!
    optional_fields = {
        # We'll include some claims to be returned in the response. NOTE: this
        # is *not* to be confused with the notion of JWT claims! JWT claims
        # will be the entire request object.
        'claims': (json.loads(environ['claims']) if 'claims' in environ else {
            "premiuminfo": {
                "address": {
                    "value": "123 Fake Street",
                },
            },
        }),
    }
    request_object.update(optional_fields)

    # So that these examples can be used for testing different outputs, allow
    # the caller to override with their own settings.
    if overrides:
        request_object.update(overrides)

    return request_object


def sign_request(jwk, raw_request_object):
    """Sign a raw request object.

    Args:
        jwk (JWK): the JWK used for signing.
        raw_request_object (dict): the raw request object, as a dict.
    """
    logger.debug('Signing request %s', raw_request_object)
    if jwk.key_type != 'RSA':
        raise ValueError('This example only supports RSA256')
    header = {
        'alg': 'RS256',
        'typ': 'JWT',
        'kid': jwk.key_id,
    }
    logger.debug('Header: %s', header)
    jwt = JWT(header=header, claims=raw_request_object)
    jwt.make_signed_token(jwk)
    return jwt.serialize()
